<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<link rel="icon" type="image/png" href="http://pgfoundry.org/images/elephant-icon.png" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>pg_reorg: Project Home Page</title>
</head>

<body>
<center><img style="border: none; margin-left: auto; margin-right: auto; " src="http://pgfoundry.org/images/elephantSmall.png" height="75" width="75" />
<hr />
<h1>Welcome to the pg_reorg Project Home Page</h1>
<hr />
</center>

<p>
This project provides two tools for PostgreSQL; <strong>pg_reorg</strong> and <strong>pg_batch</strong>.
</p>

<p>
<strong>pg_reorg</strong> can re-organize tables on a postgres database without any locks so that you can retrieve or update rows in tables being reorganized.
The module is developed to be a better alternative of CLUSTER and VACUUM FULL.
</p>

<p>
<strong>pg_batch</strong> is a SQL job executor program for PostgreSQL.
It generates job list from an external SQL script file, and execute the jobs in serial or parallel.
It can be used as "a better vacuumdb" with the attached script to run VACUUM.
</p>

<p>
The pg_reorg project is a <a href="http://www.postgresql.org">PostgreSQL</a> Community project that is a part of the <a href="http://pgfoundry.org">pgFoundry</a>.
</p>
<p>
The pgFoundry page for the project is at <a href="http://pgfoundry.org/projects/reorg">http://pgfoundry.org/projects/reorg</a>, 
where you can find <a href="http://pgfoundry.org/frs/?group_id=1000411">downloads</a>, documentation, bug reports, mailing lists, and a whole lot more.
</p>
<div>
<a href="index-ja.html">日本語のページはこちら。</a>
</div>
<hr />

<h2>Documentation</h2>

<ul>
<li><a href="pg_reorg.html">pg_reorg 1.1 documentation</a></li>
<li><a href="pg_batch.html">pg_batch 1.2 documentation</a></li>
</ul>

<h2>Execution time</h2>
<p>
Here shows the result of pg_reorg performance test.
We have compared between non-fragmented table and fragmented table.
Both tables have the same number of records, but fragmented table is bloated by UPDATEs.
</p>

<center>
<div style="margin: 2em">
<img src="result_93.png" />
</div>

<table border="1">
<caption>Configuration</caption>
<tr>
	<th>Category</th>
	<th>Item</th>
	<th>Details</th>
</tr>
<tr>
	<td rowspan="3">Hardware</td>
	<td>CPU</td>
	<td>Xeon E5645 2.4GHz (12 core) * 2</td>
</tr>
<tr>
	<td>Memory</td>
	<td>32GB</td>
</tr>
<tr>
	<td>Storage</td>
	<td>SAS 10,000rpm 2TB * 4</td>
</tr>
<tr>
	<td rowspan="3">Software</td>
	<td>OS</td>
	<td>RHEL 6.2 (64bit)</td>
</tr>
<tr>
	<td>DB</td>
	<td>PostgreSQL 9.3.4</td>
</tr>
<tr>
	<td>pg_reorg</td>
	<td>1.1.10</td>
</tr>
<tr>
	<td>Data</td>
	<td>Scheme</td>
	<td><code><pre>
CREATE TABLE test (
 id bigserial,
 rndkey bigint NOT NULL,
 dummy1 bigint NOT NULL,
 dummy2 bigint NOT NULL,
 dummy3 bigint NOT NULL,
 dummy4 bigint NOT NULL,
 dummy5 bigint NOT NULL,
 dummy6 bigint NOT NULL,
 dummy7 bigint NOT NULL,
 dummy8 timestamp NOT NULL,
 dummy9 timestamp NOT NULL,
 dummy10 timestamp NOT NULL,
 dummy11 timestamp NOT NULL,
 dummy12 timestamp NOT NULL,
 dummy13 timestamp NOT NULL,
 dummy14 timestamp NOT NULL,
 filler char(128) NOT NULL
);

CREATE INDEX test_idx_rndkey ON test (rndkey);
ALTER TABLE test CLUSTER ON test_idx_rndkey;
    </pre></code></td>
</tr>
</table>

</center>

<hr />
<p class="footer">
Portions Copyright (c) 2008-2015, NIPPON TELEGRAPH AND TELEPHONE CORPORATION<br />
</p>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10244036-4");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
